{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Data } from './data';\nimport { Table } from './table';\nimport { Vector } from './vector';\nimport { Visitor } from './visitor';\nimport { Schema } from './schema';\nimport { isIterable } from './util/compat';\nimport { Chunked } from './vector/chunked';\nimport { selectFieldArgs } from './util/args';\nimport { DataType, Struct } from './type';\nimport { ensureSameLengthData } from './util/recordbatch';\nimport { StructVector } from './vector/index';\nexport class RecordBatch extends StructVector {\n  constructor(...args) {\n    let data;\n    let schema = args[0];\n    let children;\n\n    if (args[1] instanceof Data) {\n      [, data, children] = args;\n    } else {\n      const fields = schema.fields;\n      const [, length, childData] = args;\n      data = Data.Struct(new Struct(fields), 0, length, 0, null, childData);\n    }\n\n    super(data, children);\n    this._schema = schema;\n  }\n  /** @nocollapse */\n\n\n  static from(options) {\n    if (isIterable(options['values'])) {\n      return Table.from(options);\n    }\n\n    return Table.from(options);\n  }\n  /** @nocollapse */\n\n\n  static new(...args) {\n    const [fs, xs] = selectFieldArgs(args);\n    const vs = xs.filter(x => x instanceof Vector);\n    return new RecordBatch(...ensureSameLengthData(new Schema(fs), vs.map(x => x.data)));\n  }\n\n  clone(data, children = this._children) {\n    return new RecordBatch(this._schema, data, children);\n  }\n\n  concat(...others) {\n    const schema = this._schema,\n          chunks = Chunked.flatten(this, ...others);\n    return new Table(schema, chunks.map(({\n      data\n    }) => new RecordBatch(schema, data)));\n  }\n\n  get schema() {\n    return this._schema;\n  }\n\n  get numCols() {\n    return this._schema.fields.length;\n  }\n\n  get dictionaries() {\n    return this._dictionaries || (this._dictionaries = DictionaryCollector.collect(this));\n  }\n\n  select(...columnNames) {\n    const nameToIndex = this._schema.fields.reduce((m, f, i) => m.set(f.name, i), new Map());\n\n    return this.selectAt(...columnNames.map(columnName => nameToIndex.get(columnName)).filter(x => x > -1));\n  }\n\n  selectAt(...columnIndices) {\n    const schema = this._schema.selectAt(...columnIndices);\n\n    const childData = columnIndices.map(i => this.data.childData[i]).filter(Boolean);\n    return new RecordBatch(schema, this.length, childData);\n  }\n\n}\n/**\n * An internal class used by the `RecordBatchReader` and `RecordBatchWriter`\n * implementations to differentiate between a stream with valid zero-length\n * RecordBatches, and a stream with a Schema message, but no RecordBatches.\n * @see https://github.com/apache/arrow/pull/4373\n * @ignore\n * @private\n */\n\n/* tslint:disable:class-name */\n\nexport class _InternalEmptyPlaceholderRecordBatch extends RecordBatch {\n  constructor(schema) {\n    super(schema, 0, schema.fields.map(f => Data.new(f.type, 0, 0, 0)));\n  }\n\n}\n/** @ignore */\n\nclass DictionaryCollector extends Visitor {\n  constructor() {\n    super(...arguments);\n    this.dictionaries = new Map();\n  }\n\n  static collect(batch) {\n    return new DictionaryCollector().visit(batch.data, new Struct(batch.schema.fields)).dictionaries;\n  }\n\n  visit(data, type) {\n    if (DataType.isDictionary(type)) {\n      return this.visitDictionary(data, type);\n    } else {\n      data.childData.forEach((child, i) => this.visit(child, type.children[i].type));\n    }\n\n    return this;\n  }\n\n  visitDictionary(data, type) {\n    const dictionary = data.dictionary;\n\n    if (dictionary && dictionary.length > 0) {\n      this.dictionaries.set(type.id, dictionary);\n    }\n\n    return this;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["Data","Table","Vector","Visitor","Schema","isIterable","Chunked","selectFieldArgs","DataType","Struct","ensureSameLengthData","StructVector","RecordBatch","constructor","args","data","schema","children","fields","length","childData","_schema","from","options","new","fs","xs","vs","filter","x","map","clone","_children","concat","others","chunks","flatten","numCols","dictionaries","_dictionaries","DictionaryCollector","collect","select","columnNames","nameToIndex","reduce","m","f","i","set","name","Map","selectAt","columnName","get","columnIndices","Boolean","_InternalEmptyPlaceholderRecordBatch","type","batch","visit","isDictionary","visitDictionary","forEach","child","dictionary","id"],"sources":["recordbatch.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Data } from './data';\nimport { Table } from './table';\nimport { Vector } from './vector';\nimport { Visitor } from './visitor';\nimport { Schema, Field } from './schema';\nimport { isIterable } from './util/compat';\nimport { Chunked } from './vector/chunked';\nimport { selectFieldArgs } from './util/args';\nimport { DataType, Struct, Dictionary } from './type';\nimport { ensureSameLengthData } from './util/recordbatch';\nimport { Clonable, Sliceable, Applicative } from './vector';\nimport { StructVector, VectorBuilderOptions, VectorBuilderOptionsAsync } from './vector/index';\n\ntype VectorMap = { [key: string]: Vector };\ntype Fields<T extends { [key: string]: DataType }> = (keyof T)[] | Field<T[keyof T]>[];\ntype ChildData<T extends { [key: string]: DataType }> = (Data<T[keyof T]> | Vector<T[keyof T]>)[];\n\nexport interface RecordBatch<T extends { [key: string]: DataType } = any> {\n    concat(...others: Vector<Struct<T>>[]): Table<T>;\n    slice(begin?: number, end?: number): RecordBatch<T>;\n    clone(data: Data<Struct<T>>, children?: Vector[]): RecordBatch<T>;\n}\n\nexport class RecordBatch<T extends { [key: string]: DataType } = any>\n    extends StructVector<T>\n    implements Clonable<RecordBatch<T>>,\n               Sliceable<RecordBatch<T>>,\n               Applicative<Struct<T>, Table<T>> {\n\n    public static from<T extends { [key: string]: DataType } = any, TNull = any>(options: VectorBuilderOptions<Struct<T>, TNull>): Table<T>;\n    public static from<T extends { [key: string]: DataType } = any, TNull = any>(options: VectorBuilderOptionsAsync<Struct<T>, TNull>): Promise<Table<T>>;\n    /** @nocollapse */\n    public static from<T extends { [key: string]: DataType } = any, TNull = any>(options: VectorBuilderOptions<Struct<T>, TNull> | VectorBuilderOptionsAsync<Struct<T>, TNull>) {\n        if (isIterable<(Struct<T>)['TValue'] | TNull>(options['values'])) {\n            return Table.from(options as VectorBuilderOptions<Struct<T>, TNull>);\n        }\n        return Table.from(options as VectorBuilderOptionsAsync<Struct<T>, TNull>);\n    }\n\n    public static new<T extends VectorMap = any>(children: T): RecordBatch<{ [P in keyof T]: T[P]['type'] }>;\n    public static new<T extends { [key: string]: DataType } = any>(children: ChildData<T>, fields?: Fields<T>): RecordBatch<T>;\n    /** @nocollapse */\n    public static new<T extends { [key: string]: DataType } = any>(...args: any[]) {\n        const [fs, xs] = selectFieldArgs<T>(args);\n        const vs = xs.filter((x): x is Vector<T[keyof T]> => x instanceof Vector);\n        return new RecordBatch(...ensureSameLengthData(new Schema<T>(fs), vs.map((x) => x.data)));\n    }\n\n    protected _schema: Schema;\n    protected _dictionaries?: Map<number, Vector>;\n\n    constructor(schema: Schema<T>, length: number, children: (Data | Vector)[]);\n    constructor(schema: Schema<T>, data: Data<Struct<T>>, children?: Vector[]);\n    constructor(...args: any[]) {\n        let data: Data<Struct<T>>;\n        let schema = args[0] as Schema<T>;\n        let children: Vector[] | undefined;\n        if (args[1] instanceof Data) {\n            [, data, children] = (args as [any, Data<Struct<T>>, Vector<T[keyof T]>[]?]);\n        } else {\n            const fields = schema.fields as Field<T[keyof T]>[];\n            const [, length, childData] = args as [any, number, Data<T[keyof T]>[]];\n            data = Data.Struct(new Struct<T>(fields), 0, length, 0, null, childData);\n        }\n        super(data, children);\n        this._schema = schema;\n    }\n\n    public clone(data: Data<Struct<T>>, children = this._children) {\n        return new RecordBatch<T>(this._schema, data, children);\n    }\n\n    public concat(...others: Vector<Struct<T>>[]): Table<T> {\n        const schema = this._schema, chunks = Chunked.flatten(this, ...others);\n        return new Table(schema, chunks.map(({ data }) => new RecordBatch(schema, data)));\n    }\n\n    public get schema() { return this._schema; }\n    public get numCols() { return this._schema.fields.length; }\n    public get dictionaries() {\n        return this._dictionaries || (this._dictionaries = DictionaryCollector.collect(this));\n    }\n\n    public select<K extends keyof T = any>(...columnNames: K[]) {\n        const nameToIndex = this._schema.fields.reduce((m, f, i) => m.set(f.name as K, i), new Map<K, number>());\n        return this.selectAt(...columnNames.map((columnName) => nameToIndex.get(columnName)!).filter((x) => x > -1));\n    }\n    public selectAt<K extends T[keyof T] = any>(...columnIndices: number[]) {\n        const schema = this._schema.selectAt(...columnIndices);\n        const childData = columnIndices.map((i) => this.data.childData[i]).filter(Boolean);\n        return new RecordBatch<{ [key: string]: K }>(schema, this.length, childData);\n    }\n}\n\n/**\n * An internal class used by the `RecordBatchReader` and `RecordBatchWriter`\n * implementations to differentiate between a stream with valid zero-length\n * RecordBatches, and a stream with a Schema message, but no RecordBatches.\n * @see https://github.com/apache/arrow/pull/4373\n * @ignore\n * @private\n */\n/* tslint:disable:class-name */\nexport class _InternalEmptyPlaceholderRecordBatch<T extends { [key: string]: DataType } = any> extends RecordBatch<T> {\n    constructor(schema: Schema<T>) {\n        super(schema, 0, schema.fields.map((f) => Data.new(f.type, 0, 0, 0)));\n    }\n}\n\n/** @ignore */\nclass DictionaryCollector extends Visitor {\n    public dictionaries = new Map<number, Vector>();\n    public static collect<T extends RecordBatch>(batch: T) {\n        return new DictionaryCollector().visit(\n            batch.data, new Struct(batch.schema.fields)\n        ).dictionaries;\n    }\n    public visit(data: Data, type: DataType) {\n        if (DataType.isDictionary(type)) {\n            return this.visitDictionary(data, type);\n        } else {\n            data.childData.forEach((child, i) =>\n                this.visit(child, type.children[i].type));\n        }\n        return this;\n    }\n    public visitDictionary(data: Data, type: Dictionary) {\n        const dictionary = data.dictionary;\n        if (dictionary && dictionary.length > 0) {\n            this.dictionaries.set(type.id, dictionary);\n        }\n        return this;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}